function dxdt = linearized_rel_orbital_dynamics(t, x, mu, a, e)
    % Evaluate orbital parameters at time t
    [rT, omegaT, omegaT_dot] = kepler_orbital_elements_eval(t, mu, a, e);

    %Construct Dynamics
    A = zeros(6,6);
    A(1:3, 4:6) = eye(3);
    A(4,:) = [3*omegaT^2, omegaT_dot, 0, 0, 2*omegaT, 0];
    A(5,:) = [-omegaT_dot, 0, 0, -2*omegaT, 0, 0];
    A(6,:) = [0, 0, -omegaT^2, 0, 0, 0];


    % implement dynamics (debugging with CWH)
    n = sqrt(mu/a^3);
    A = [zeros([3 3]) eye(3); 3*n^2 0 0 0 2*n 0;...
        zeros([1 3]) -2*n 0 0; 0 0 -n^2 0 0 0];

    B = [zeros(3,3); eye(3)];


    %define Q and R
    Q = zeros(6,6);

    Q(1:3,1:3) = eye(3).*0.01;
    Q(4:6,4:6) = eye(3).*0.001;

    R = eye(3).*10^2;

    %implement SDRE

    %define hamiltonian matrix
    HM = [A,    -B*inv(R)*B';
          -Q,        -A'    ];

    [V,D] = eig(HM);

    eigvals = real(diag(D));
    n = 0;
    for i = 1:length(eigvals)
        if eigvals(i) > 0
            n = n+1;
        end
    end

    if n ~= 6
        error('wrong number of eigvals with negative real part')
    end

    [X,Y] = ric_schr(HM);

    P = X*inv(Y);

    k = -inv(R)* B'* P;

    riccati_val = P*A + A'*P - P*B*inv(R)*B'*P + Q

    u =  k * x;

    %u = zeros(3,1); %Eventually replace with SDRE input directly here? 

    dxdt = A*x + B*u;

    %debugging, adding the extra \ddot{x} terms to see if it fixes x
    %behavior (unsuccessful)
    %dxdt(4) = dxdt(4) + omegaT^2*rT;% - mu/(rT^2);
end


